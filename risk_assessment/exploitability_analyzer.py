#!/usr/bin/env python3
"""
Exploitability Analyzer
Portfolio Demo: LLM Security Vulnerability Exploitability Assessment Framework

Author: Sotiris Spyrou
LinkedIn: https://www.linkedin.com/in/sspyrou/
Company: VerityAI - https://verityai.co

DISCLAIMER: This is demonstration code for portfolio purposes only.
Not intended for production use. For professional exploitability assessment,
contact VerityAI at https://verityai.co
"""

import json
import logging
import numpy as np
from typing import Dict, List, Optional, Tuple, Any, Union
from dataclasses import dataclass, asdict
from datetime import datetime
from enum import Enum
from collections import defaultdict
import statistics

class VulnerabilityType(Enum):
    """Types of LLM security vulnerabilities."""
    PROMPT_INJECTION = "prompt_injection"
    SYSTEM_PROMPT_EXTRACTION = "system_prompt_extraction"
    INFORMATION_LEAKAGE = "information_leakage"
    CONVERSATION_HIJACKING = "conversation_hijacking"
    CONTEXT_MANIPULATION = "context_manipulation"
    SAFETY_BYPASS = "safety_bypass"
    AUTHORIZATION_BYPASS = "authorization_bypass"
    DATA_POISONING = "data_poisoning"
    MODEL_INVERSION = "model_inversion"
    MEMBERSHIP_INFERENCE = "membership_inference"

class ExploitComplexity(Enum):
    """Complexity levels for exploiting vulnerabilities."""
    LOW = "low"          # Minimal skill/tools required
    MEDIUM = "medium"    # Moderate skill/specialized tools
    HIGH = "high"        # Advanced skill/custom tools
    CRITICAL = "critical"  # Expert-level/sophisticated resources

class AccessVector(Enum):
    """How the vulnerability can be accessed."""
    NETWORK = "network"      # Remote network access
    ADJACENT = "adjacent"    # Adjacent network access
    LOCAL = "local"          # Local access required
    PHYSICAL = "physical"    # Physical access required

class PrivilegeLevel(Enum):
    """Required privilege level for exploitation."""
    NONE = "none"           # No privileges required
    LOW = "low"             # Basic user privileges
    HIGH = "high"           # Elevated privileges required
    ADMIN = "admin"         # Administrative access required

@dataclass
class ExploitabilityVector:
    """CVSS-inspired exploitability scoring vector for LLM vulnerabilities."""
    access_vector: AccessVector
    attack_complexity: ExploitComplexity
    privileges_required: PrivilegeLevel
    user_interaction: bool  # Does exploit require user interaction?
    skill_level_required: str
    time_to_exploit: str
    detection_likelihood: str

@dataclass
class VulnerabilityAssessment:
    """Individual vulnerability exploitability assessment."""
    vulnerability_id: str
    vulnerability_type: VulnerabilityType
    description: str
    exploitability_vector: ExploitabilityVector
    technical_details: Dict[str, Any]
    proof_of_concept: Optional[str]
    business_context: Dict[str, Any]

@dataclass
class ExploitabilityResult:
    """Results from exploitability analysis."""
    vulnerability_id: str
    exploitability_score: float
    exploitability_rating: str
    attack_scenarios: List[Dict[str, Any]]
    mitigation_difficulty: str
    exploitation_timeline: Dict[str, str]
    business_risk_level: str
    recommendation_priority: str

class ExploitabilityAnalyzer:
    """
    Advanced exploitability assessment framework for LLM security vulnerabilities - Portfolio demonstration.
    
    EXECUTIVE VALUE PROPOSITION:
    - Quantifies vulnerability exploitability with data-driven risk scoring
    - Prioritizes security investments based on actual threat likelihood
    - Enables proactive vulnerability management and resource allocation
    - Provides CISO-level risk assessment for AI system security posture
    
    STRATEGIC POSITIONING:
    Demonstrates sophisticated understanding of cybersecurity risk quantification
    applied to cutting-edge AI systems - essential capability for enterprises
    deploying LLMs in production environments.
    """
    
    def __init__(self):
        self.logger = logging.getLogger(__name__)
        self.scoring_matrix = self._initialize_scoring_matrix()
        self.attack_patterns = self._initialize_attack_patterns()
        
    def _initialize_scoring_matrix(self) -> Dict[str, Dict]:
        """Initialize CVSS-inspired scoring matrix for LLM vulnerabilities."""
        return {
            "access_vector": {
                AccessVector.NETWORK: 0.85,
                AccessVector.ADJACENT: 0.62,
                AccessVector.LOCAL: 0.55,
                AccessVector.PHYSICAL: 0.20
            },
            "attack_complexity": {
                ExploitComplexity.LOW: 0.77,
                ExploitComplexity.MEDIUM: 0.44,
                ExploitComplexity.HIGH: 0.35,
                ExploitComplexity.CRITICAL: 0.15
            },
            "privileges_required": {
                PrivilegeLevel.NONE: 0.85,
                PrivilegeLevel.LOW: 0.62,
                PrivilegeLevel.HIGH: 0.27,
                PrivilegeLevel.ADMIN: 0.13
            },
            "user_interaction": {
                True: 0.62,   # Requires user interaction
                False: 0.85   # No user interaction required
            }
        }
    
    def _initialize_attack_patterns(self) -> Dict[VulnerabilityType, Dict]:
        """Initialize known attack patterns for different vulnerability types."""
        return {
            VulnerabilityType.PROMPT_INJECTION: {
                "common_vectors": [
                    "Direct instruction override",
                    "Context manipulation",
                    "Role confusion attacks",
                    "Template injection"
                ],
                "typical_complexity": ExploitComplexity.LOW,
                "average_detection_time": "2-7 days",
                "skill_requirement": "Basic scripting knowledge"
            },
            
            VulnerabilityType.SYSTEM_PROMPT_EXTRACTION: {
                "common_vectors": [
                    "Direct prompt requests",
                    "Reverse engineering techniques",
                    "Context confusion methods",
                    "Encoding-based extraction"
                ],
                "typical_complexity": ExploitComplexity.MEDIUM,
                "average_detection_time": "1-14 days",
                "skill_requirement": "Intermediate AI knowledge"
            },
            
            VulnerabilityType.INFORMATION_LEAKAGE: {
                "common_vectors": [
                    "Training data extraction",
                    "PII exposure through responses",
                    "Indirect information inference",
                    "Context-based data leakage"
                ],
                "typical_complexity": ExploitComplexity.MEDIUM,
                "average_detection_time": "7-30 days",
                "skill_requirement": "Data analysis skills"
            },
            
            VulnerabilityType.CONVERSATION_HIJACKING: {
                "common_vectors": [
                    "Topic redirection attacks",
                    "Authority spoofing",
                    "Emotional manipulation",
                    "Urgency injection"
                ],
                "typical_complexity": ExploitComplexity.LOW,
                "average_detection_time": "Immediate-3 days",
                "skill_requirement": "Social engineering basics"
            },
            
            VulnerabilityType.CONTEXT_MANIPULATION: {
                "common_vectors": [
                    "False memory injection",
                    "Historical context revision",
                    "State corruption attacks",
                    "Temporal manipulation"
                ],
                "typical_complexity": ExploitComplexity.MEDIUM,
                "average_detection_time": "3-14 days",
                "skill_requirement": "Advanced prompting techniques"
            },
            
            VulnerabilityType.SAFETY_BYPASS: {
                "common_vectors": [
                    "Content filter evasion",
                    "Ethical guideline circumvention",
                    "Safety mechanism override",
                    "Harmful output generation"
                ],
                "typical_complexity": ExploitComplexity.HIGH,
                "average_detection_time": "1-7 days",
                "skill_requirement": "Advanced AI safety knowledge"
            }
        }
    
    def analyze_vulnerability_exploitability(
        self,
        vulnerability: VulnerabilityAssessment
    ) -> ExploitabilityResult:
        """
        Analyze the exploitability of a specific vulnerability.
        
        Returns comprehensive exploitability assessment with business context.
        """
        self.logger.info(f"Analyzing exploitability for {vulnerability.vulnerability_id}")
        
        # Calculate base exploitability score
        base_score = self._calculate_base_exploitability_score(vulnerability.exploitability_vector)
        
        # Apply vulnerability-specific adjustments
        adjusted_score = self._apply_vulnerability_adjustments(
            base_score, vulnerability.vulnerability_type, vulnerability.technical_details
        )
        
        # Generate exploitability rating
        rating = self._calculate_exploitability_rating(adjusted_score)
        
        # Generate attack scenarios
        attack_scenarios = self._generate_attack_scenarios(vulnerability)
        
        # Assess mitigation difficulty
        mitigation_difficulty = self._assess_mitigation_difficulty(vulnerability)
        
        # Create exploitation timeline
        exploitation_timeline = self._create_exploitation_timeline(vulnerability)
        
        # Determine business risk level
        business_risk = self._assess_business_risk_level(
            adjusted_score, vulnerability.business_context
        )
        
        # Calculate recommendation priority
        priority = self._calculate_recommendation_priority(
            adjusted_score, business_risk, mitigation_difficulty
        )
        
        return ExploitabilityResult(
            vulnerability_id=vulnerability.vulnerability_id,
            exploitability_score=adjusted_score,
            exploitability_rating=rating,
            attack_scenarios=attack_scenarios,
            mitigation_difficulty=mitigation_difficulty,
            exploitation_timeline=exploitation_timeline,
            business_risk_level=business_risk,
            recommendation_priority=priority
        )
    
    def _calculate_base_exploitability_score(self, vector: ExploitabilityVector) -> float:
        """Calculate base exploitability score using CVSS-inspired methodology."""
        
        # Get component scores
        av_score = self.scoring_matrix["access_vector"][vector.access_vector]
        ac_score = self.scoring_matrix["attack_complexity"][vector.attack_complexity]
        pr_score = self.scoring_matrix["privileges_required"][vector.privileges_required]
        ui_score = self.scoring_matrix["user_interaction"][vector.user_interaction]
        
        # Calculate exploitability subscore (CVSS methodology adapted for LLMs)
        exploitability = 8.22 * av_score * ac_score * pr_score * ui_score
        
        # Normalize to 0-10 scale
        normalized_score = min(10.0, max(0.0, exploitability))
        
        return normalized_score
    
    def _apply_vulnerability_adjustments(
        self,
        base_score: float,
        vuln_type: VulnerabilityType,
        technical_details: Dict[str, Any]
    ) -> float:
        """Apply vulnerability-specific adjustments to base score."""
        
        adjustment_factor = 1.0
        
        # Vulnerability type specific adjustments
        type_adjustments = {
            VulnerabilityType.PROMPT_INJECTION: 1.2,      # Generally easier to exploit
            VulnerabilityType.SYSTEM_PROMPT_EXTRACTION: 1.1,
            VulnerabilityType.INFORMATION_LEAKAGE: 0.9,
            VulnerabilityType.CONVERSATION_HIJACKING: 1.15,
            VulnerabilityType.CONTEXT_MANIPULATION: 0.95,
            VulnerabilityType.SAFETY_BYPASS: 0.8,         # Usually harder to exploit
            VulnerabilityType.AUTHORIZATION_BYPASS: 0.7,
            VulnerabilityType.DATA_POISONING: 0.6,
            VulnerabilityType.MODEL_INVERSION: 0.5,
            VulnerabilityType.MEMBERSHIP_INFERENCE: 0.5
        }
        
        adjustment_factor *= type_adjustments.get(vuln_type, 1.0)
        
        # Technical detail adjustments
        if technical_details.get('proof_of_concept_available', False):
            adjustment_factor *= 1.3
        
        if technical_details.get('automated_exploitation_possible', False):
            adjustment_factor *= 1.4
        
        if technical_details.get('widespread_applicability', False):
            adjustment_factor *= 1.2
        
        # Apply environmental factors
        if technical_details.get('requires_specific_model_version', False):
            adjustment_factor *= 0.8
        
        if technical_details.get('requires_specific_configuration', False):
            adjustment_factor *= 0.7
        
        adjusted_score = min(10.0, base_score * adjustment_factor)
        return adjusted_score
    
    def _calculate_exploitability_rating(self, score: float) -> str:
        """Convert numerical score to categorical rating."""
        if score >= 9.0:
            return "critical"
        elif score >= 7.0:
            return "high"
        elif score >= 4.0:
            return "medium"
        else:
            return "low"
    
    def _generate_attack_scenarios(self, vulnerability: VulnerabilityAssessment) -> List[Dict[str, Any]]:
        """Generate realistic attack scenarios for the vulnerability."""
        
        vuln_patterns = self.attack_patterns.get(
            vulnerability.vulnerability_type, 
            {"common_vectors": ["Unknown attack vector"]}
        )
        
        scenarios = []
        
        # Basic attack scenario
        scenarios.append({
            "scenario_name": "Basic Exploitation",
            "description": f"Attacker exploits {vulnerability.vulnerability_type.value} using standard techniques",
            "attack_steps": [
                "Reconnaissance and target identification",
                "Vulnerability discovery and validation",
                f"Exploit development using {vuln_patterns.get('skill_requirement', 'standard techniques')}",
                "Payload deployment and execution",
                "Impact realization and persistence"
            ],
            "required_skills": vuln_patterns.get('skill_requirement', 'Basic technical knowledge'),
            "time_to_exploit": vuln_patterns.get('average_detection_time', '1-7 days'),
            "success_probability": self._calculate_success_probability(vulnerability),
            "detection_likelihood": vulnerability.exploitability_vector.detection_likelihood
        })
        
        # Advanced attack scenario (if applicable)
        if vulnerability.exploitability_vector.attack_complexity in [ExploitComplexity.LOW, ExploitComplexity.MEDIUM]:
            scenarios.append({
                "scenario_name": "Automated Mass Exploitation",
                "description": f"Automated exploitation of {vulnerability.vulnerability_type.value} at scale",
                "attack_steps": [
                    "Target enumeration and vulnerability scanning",
                    "Automated exploit deployment",
                    "Mass data collection or system compromise",
                    "Persistence and lateral movement"
                ],
                "required_skills": "Advanced scripting and automation",
                "time_to_exploit": "Hours to days (automated)",
                "success_probability": max(0.3, self._calculate_success_probability(vulnerability) - 0.2),
                "detection_likelihood": "Medium (due to scale)"
            })
        
        # Insider threat scenario
        if vulnerability.exploitability_vector.privileges_required in [PrivilegeLevel.LOW, PrivilegeLevel.HIGH]:
            scenarios.append({
                "scenario_name": "Insider Threat Exploitation",
                "description": f"Privileged user exploits {vulnerability.vulnerability_type.value} for unauthorized access",
                "attack_steps": [
                    "Leverage existing system access",
                    "Exploit vulnerability using insider knowledge",
                    "Extract sensitive information or bypass controls",
                    "Cover tracks and maintain access"
                ],
                "required_skills": "System familiarity and basic technical knowledge",
                "time_to_exploit": "Minutes to hours",
                "success_probability": min(0.9, self._calculate_success_probability(vulnerability) + 0.3),
                "detection_likelihood": "Low (trusted user activity)"
            })
        
        return scenarios
    
    def _calculate_success_probability(self, vulnerability: VulnerabilityAssessment) -> float:
        """Calculate probability of successful exploitation."""
        
        base_probability = 0.5
        
        # Complexity adjustments
        complexity_adjustments = {
            ExploitComplexity.LOW: 0.3,
            ExploitComplexity.MEDIUM: 0.1,
            ExploitComplexity.HIGH: -0.1,
            ExploitComplexity.CRITICAL: -0.3
        }
        
        base_probability += complexity_adjustments.get(
            vulnerability.exploitability_vector.attack_complexity, 0
        )
        
        # Access vector adjustments
        if vulnerability.exploitability_vector.access_vector == AccessVector.NETWORK:
            base_probability += 0.2
        elif vulnerability.exploitability_vector.access_vector == AccessVector.PHYSICAL:
            base_probability -= 0.3
        
        # User interaction adjustment
        if vulnerability.exploitability_vector.user_interaction:
            base_probability -= 0.1
        
        return max(0.1, min(0.95, base_probability))
    
    def _assess_mitigation_difficulty(self, vulnerability: VulnerabilityAssessment) -> str:
        """Assess difficulty of mitigating the vulnerability."""
        
        # Base difficulty assessment
        base_factors = {
            VulnerabilityType.PROMPT_INJECTION: "medium",
            VulnerabilityType.SYSTEM_PROMPT_EXTRACTION: "hard",
            VulnerabilityType.INFORMATION_LEAKAGE: "medium",
            VulnerabilityType.CONVERSATION_HIJACKING: "easy",
            VulnerabilityType.CONTEXT_MANIPULATION: "medium",
            VulnerabilityType.SAFETY_BYPASS: "hard",
            VulnerabilityType.AUTHORIZATION_BYPASS: "medium",
            VulnerabilityType.DATA_POISONING: "hard",
            VulnerabilityType.MODEL_INVERSION: "very_hard",
            VulnerabilityType.MEMBERSHIP_INFERENCE: "very_hard"
        }
        
        base_difficulty = base_factors.get(vulnerability.vulnerability_type, "medium")
        
        # Adjust based on technical details
        technical = vulnerability.technical_details
        
        if technical.get('requires_model_retraining', False):
            return "very_hard"
        elif technical.get('requires_architectural_changes', False):
            return "hard"
        elif technical.get('configuration_fix_available', False):
            return "easy"
        
        return base_difficulty
    
    def _create_exploitation_timeline(self, vulnerability: VulnerabilityAssessment) -> Dict[str, str]:
        """Create realistic exploitation timeline."""
        
        complexity = vulnerability.exploitability_vector.attack_complexity
        
        timeline_mapping = {
            ExploitComplexity.LOW: {
                "discovery_to_exploit": "Hours to 1 day",
                "exploit_to_impact": "Minutes to hours",
                "detection_window": "1-3 days",
                "full_compromise": "1-7 days"
            },
            ExploitComplexity.MEDIUM: {
                "discovery_to_exploit": "1-7 days",
                "exploit_to_impact": "Hours to 1 day",
                "detection_window": "3-14 days",
                "full_compromise": "7-30 days"
            },
            ExploitComplexity.HIGH: {
                "discovery_to_exploit": "1-4 weeks",
                "exploit_to_impact": "1-7 days",
                "detection_window": "7-30 days",
                "full_compromise": "30-90 days"
            },
            ExploitComplexity.CRITICAL: {
                "discovery_to_exploit": "1-6 months",
                "exploit_to_impact": "1-14 days",
                "detection_window": "14-90 days",
                "full_compromise": "90+ days"
            }
        }
        
        return timeline_mapping.get(complexity, timeline_mapping[ExploitComplexity.MEDIUM])
    
    def _assess_business_risk_level(
        self,
        exploitability_score: float,
        business_context: Dict[str, Any]
    ) -> str:
        """Assess business risk level considering exploitability and business context."""
        
        # Base risk from exploitability score
        if exploitability_score >= 9.0:
            base_risk = "critical"
        elif exploitability_score >= 7.0:
            base_risk = "high"
        elif exploitability_score >= 4.0:
            base_risk = "medium"
        else:
            base_risk = "low"
        
        # Business context adjustments
        risk_multipliers = []
        
        if business_context.get('customer_facing', False):
            risk_multipliers.append(1.5)
        
        if business_context.get('handles_sensitive_data', False):
            risk_multipliers.append(1.4)
        
        if business_context.get('regulatory_environment', '') in ['financial', 'healthcare', 'government']:
            risk_multipliers.append(1.6)
        
        if business_context.get('public_reputation_impact', False):
            risk_multipliers.append(1.3)
        
        # Calculate final risk multiplier
        final_multiplier = 1.0
        for multiplier in risk_multipliers:
            final_multiplier *= multiplier
        
        # Adjust risk level based on business context
        adjusted_score = exploitability_score * final_multiplier
        
        if adjusted_score >= 12.0:
            return "critical"
        elif adjusted_score >= 8.5:
            return "high"
        elif adjusted_score >= 5.0:
            return "medium"
        else:
            return "low"
    
    def _calculate_recommendation_priority(
        self,
        exploitability_score: float,
        business_risk: str,
        mitigation_difficulty: str
    ) -> str:
        """Calculate priority for remediation recommendations."""
        
        # Priority scoring matrix
        priority_scores = {
            "critical": 10,
            "high": 8,
            "medium": 5,
            "low": 2
        }
        
        difficulty_penalties = {
            "easy": 0,
            "medium": -1,
            "hard": -2,
            "very_hard": -3
        }
        
        base_score = priority_scores.get(business_risk, 5)
        difficulty_penalty = difficulty_penalties.get(mitigation_difficulty, -1)
        
        # Exploitability boost
        if exploitability_score >= 9.0:
            exploitability_boost = 2
        elif exploitability_score >= 7.0:
            exploitability_boost = 1
        else:
            exploitability_boost = 0
        
        final_score = base_score + exploitability_boost + difficulty_penalty
        
        if final_score >= 10:
            return "immediate"
        elif final_score >= 8:
            return "urgent"
        elif final_score >= 5:
            return "high"
        elif final_score >= 3:
            return "medium"
        else:
            return "low"
    
    def analyze_portfolio_exploitability(
        self,
        vulnerabilities: List[VulnerabilityAssessment]
    ) -> Dict[str, Any]:
        """
        Analyze exploitability across a portfolio of vulnerabilities.
        
        Returns comprehensive portfolio-level risk assessment.
        """
        self.logger.info(f"Analyzing portfolio exploitability for {len(vulnerabilities)} vulnerabilities")
        
        results = []
        
        # Analyze each vulnerability
        for vuln in vulnerabilities:
            result = self.analyze_vulnerability_exploitability(vuln)
            results.append(result)
        
        # Portfolio-level analysis
        portfolio_analysis = self._analyze_portfolio_results(results, vulnerabilities)
        
        return {
            'analysis_timestamp': datetime.now().isoformat(),
            'total_vulnerabilities': len(vulnerabilities),
            'individual_results': results,
            'portfolio_analysis': portfolio_analysis,
            'executive_summary': self._generate_executive_summary(portfolio_analysis, results),
            'strategic_recommendations': self._generate_strategic_recommendations(portfolio_analysis, results)
        }
    
    def _analyze_portfolio_results(
        self,
        results: List[ExploitabilityResult],
        vulnerabilities: List[VulnerabilityAssessment]
    ) -> Dict[str, Any]:
        """Analyze portfolio-level exploitability patterns."""
        
        if not results:
            return {'error': 'No results to analyze'}
        
        # Score distribution
        scores = [r.exploitability_score for r in results]
        score_stats = {
            'mean': statistics.mean(scores),
            'median': statistics.median(scores),
            'max': max(scores),
            'min': min(scores),
            'std_dev': statistics.stdev(scores) if len(scores) > 1 else 0
        }
        
        # Rating distribution
        rating_counts = defaultdict(int)
        for result in results:
            rating_counts[result.exploitability_rating] += 1
        
        # Risk level distribution
        risk_counts = defaultdict(int)
        for result in results:
            risk_counts[result.business_risk_level] += 1
        
        # Priority distribution
        priority_counts = defaultdict(int)
        for result in results:
            priority_counts[result.recommendation_priority] += 1
        
        # Vulnerability type analysis
        type_analysis = defaultdict(lambda: {'count': 0, 'avg_score': 0, 'scores': []})
        for vuln, result in zip(vulnerabilities, results):
            vuln_type = vuln.vulnerability_type.value
            type_analysis[vuln_type]['count'] += 1
            type_analysis[vuln_type]['scores'].append(result.exploitability_score)
        
        # Calculate averages for each type
        for vuln_type in type_analysis:
            scores = type_analysis[vuln_type]['scores']
            type_analysis[vuln_type]['avg_score'] = statistics.mean(scores)
            type_analysis[vuln_type]['max_score'] = max(scores)
        
        # Identify highest risk vulnerabilities
        critical_vulns = [r for r in results if r.business_risk_level == 'critical']
        high_risk_vulns = [r for r in results if r.exploitability_score >= 7.0]
        
        # Calculate portfolio risk score
        portfolio_risk_score = self._calculate_portfolio_risk_score(results)
        
        return {
            'score_statistics': score_stats,
            'rating_distribution': dict(rating_counts),
            'risk_level_distribution': dict(risk_counts),
            'priority_distribution': dict(priority_counts),
            'vulnerability_type_analysis': dict(type_analysis),
            'critical_vulnerabilities': len(critical_vulns),
            'high_exploitability_vulnerabilities': len(high_risk_vulns),
            'portfolio_risk_score': portfolio_risk_score,
            'portfolio_risk_level': self._determine_portfolio_risk_level(portfolio_risk_score, results),
            'most_exploitable_vulnerability': max(results, key=lambda x: x.exploitability_score).vulnerability_id,
            'immediate_action_required': len([r for r in results if r.recommendation_priority == 'immediate'])
        }
    
    def _calculate_portfolio_risk_score(self, results: List[ExploitabilityResult]) -> float:
        """Calculate overall portfolio risk score."""
        
        if not results:
            return 0.0
        
        # Weighted average based on business risk levels
        risk_weights = {
            'critical': 4.0,
            'high': 3.0,
            'medium': 2.0,
            'low': 1.0
        }
        
        weighted_sum = 0.0
        total_weight = 0.0
        
        for result in results:
            weight = risk_weights.get(result.business_risk_level, 1.0)
            weighted_sum += result.exploitability_score * weight
            total_weight += weight
        
        return weighted_sum / total_weight if total_weight > 0 else 0.0
    
    def _determine_portfolio_risk_level(
        self,
        portfolio_score: float,
        results: List[ExploitabilityResult]
    ) -> str:
        """Determine overall portfolio risk level."""
        
        critical_count = len([r for r in results if r.business_risk_level == 'critical'])
        high_count = len([r for r in results if r.business_risk_level == 'high'])
        
        if critical_count >= 3 or portfolio_score >= 8.5:
            return "critical"
        elif critical_count >= 1 or high_count >= 5 or portfolio_score >= 6.5:
            return "high"
        elif high_count >= 2 or portfolio_score >= 4.5:
            return "medium"
        else:
            return "low"
    
    def _generate_executive_summary(
        self,
        portfolio_analysis: Dict[str, Any],
        results: List[ExploitabilityResult]
    ) -> Dict[str, Any]:
        """Generate executive-level summary of exploitability analysis."""
        
        portfolio_risk = portfolio_analysis.get('portfolio_risk_level', 'unknown')
        critical_vulns = portfolio_analysis.get('critical_vulnerabilities', 0)
        immediate_actions = portfolio_analysis.get('immediate_action_required', 0)
        
        # Risk assessment summary
        if portfolio_risk == 'critical':
            risk_statement = "CRITICAL: Immediate executive attention required - multiple high-exploitability vulnerabilities pose significant business risk"
        elif portfolio_risk == 'high':
            risk_statement = "HIGH: Urgent security investment needed - exploitable vulnerabilities threaten business operations"
        elif portfolio_risk == 'medium':
            risk_statement = "MEDIUM: Moderate security improvements recommended - manageable risk level with targeted mitigation"
        else:
            risk_statement = "LOW: Security posture adequate - standard monitoring and maintenance recommended"
        
        # Business impact assessment
        avg_score = portfolio_analysis.get('score_statistics', {}).get('mean', 0)
        impact_assessment = {
            'customer_trust_risk': 'high' if critical_vulns >= 2 else 'medium' if avg_score >= 6 else 'low',
            'regulatory_compliance_risk': 'high' if critical_vulns >= 1 else 'medium' if avg_score >= 5 else 'low',
            'operational_continuity_risk': 'high' if immediate_actions >= 3 else 'medium' if immediate_actions >= 1 else 'low',
            'competitive_advantage_risk': 'medium' if avg_score >= 7 else 'low'
        }
        
        return {
            'risk_statement': risk_statement,
            'portfolio_risk_level': portfolio_risk,
            'total_vulnerabilities_assessed': len(results),
            'critical_vulnerabilities': critical_vulns,
            'immediate_remediation_required': immediate_actions,
            'average_exploitability_score': avg_score,
            'business_impact_assessment': impact_assessment,
            'executive_action_required': immediate_actions > 0 or critical_vulns > 0
        }
    
    def _generate_strategic_recommendations(
        self,
        portfolio_analysis: Dict[str, Any],
        results: List[ExploitabilityResult]
    ) -> List[str]:
        """Generate strategic recommendations based on portfolio analysis."""
        
        recommendations = []
        
        critical_vulns = portfolio_analysis.get('critical_vulnerabilities', 0)
        immediate_actions = portfolio_analysis.get('immediate_action_required', 0)
        portfolio_risk = portfolio_analysis.get('portfolio_risk_level', 'low')
        
        # Critical vulnerability recommendations
        if critical_vulns >= 3:
            recommendations.append(
                "IMMEDIATE: Establish dedicated security response team for critical LLM vulnerabilities"
            )
        elif critical_vulns >= 1:
            recommendations.append(
                "URGENT: Prioritize remediation of critical vulnerabilities within 48-72 hours"
            )
        
        # Portfolio-level recommendations
        if portfolio_risk == 'critical':
            recommendations.extend([
                "STRATEGIC: Implement comprehensive LLM security framework with continuous monitoring",
                "OPERATIONAL: Increase security testing frequency to weekly assessments",
                "INVESTMENT: Allocate emergency budget for immediate security improvements"
            ])
        elif portfolio_risk == 'high':
            recommendations.extend([
                "STRATEGIC: Develop formal LLM vulnerability management program",
                "OPERATIONAL: Implement bi-weekly security assessments and monitoring"
            ])
        
        # Technical recommendations based on vulnerability types
        type_analysis = portfolio_analysis.get('vulnerability_type_analysis', {})
        high_risk_types = [
            vtype for vtype, data in type_analysis.items()
            if data.get('avg_score', 0) >= 7.0
        ]
        
        if high_risk_types:
            recommendations.append(
                f"TECHNICAL: Focus security hardening efforts on {', '.join(high_risk_types)} vulnerabilities"
            )
        
        # Immediate action recommendations
        if immediate_actions >= 5:
            recommendations.append(
                "RESOURCE: Consider external security consulting for rapid vulnerability remediation"
            )
        
        # Always include professional consultation
        recommendations.append(
            "STRATEGIC: Consider professional LLM security assessment from VerityAI for comprehensive risk management"
        )
        
        return recommendations[:8]  # Limit to top 8 recommendations
    
    def generate_exploitability_report(self, analysis_results: Dict[str, Any]) -> str:
        """Generate comprehensive exploitability assessment report."""
        
        portfolio_analysis = analysis_results.get('portfolio_analysis', {})
        executive_summary = analysis_results.get('executive_summary', {})
        
        # Determine security status emoji
        portfolio_risk = portfolio_analysis.get('portfolio_risk_level', 'unknown')
        security_emoji = {
            'critical': '🚨', 'high': '🔴', 'medium': '🟡', 'low': '🟢'
        }.get(portfolio_risk, '❓')
        
        report = f"""
# LLM Security Exploitability Assessment Report

**Assessment Date**: {datetime.now().strftime('%B %d, %Y')}
**Prepared by**: Sotiris Spyrou | VerityAI LLM Security Services

## Executive Summary

### Security Risk Status: {security_emoji} {portfolio_risk.upper().replace('_', ' ')}

{executive_summary.get('risk_statement', 'Risk assessment unavailable')}

**Key Metrics:**
- **Total Vulnerabilities Assessed**: {analysis_results['total_vulnerabilities']:,}
- **Critical Vulnerabilities**: {executive_summary.get('critical_vulnerabilities', 0)}
- **Average Exploitability Score**: {executive_summary.get('average_exploitability_score', 0):.1f}/10.0
- **Immediate Actions Required**: {executive_summary.get('immediate_remediation_required', 0)}

### Business Impact Assessment
"""
        
        # Business impact details
        impact = executive_summary.get('business_impact_assessment', {})
        for impact_type, level in impact.items():
            impact_name = impact_type.replace('_', ' ').title()
            risk_emoji = {'high': '🔴', 'medium': '🟡', 'low': '🟢'}.get(level, '❓')
            report += f"- **{impact_name}**: {risk_emoji} {level.upper()}\n"
        
        # Exploitability Score Distribution
        report += f"""

### Exploitability Score Distribution
"""
        score_stats = portfolio_analysis.get('score_statistics', {})
        report += f"""- **Mean Score**: {score_stats.get('mean', 0):.2f}/10.0
- **Median Score**: {score_stats.get('median', 0):.2f}/10.0
- **Highest Risk**: {score_stats.get('max', 0):.2f}/10.0
- **Standard Deviation**: {score_stats.get('std_dev', 0):.2f}

"""
        
        # Rating distribution
        rating_dist = portfolio_analysis.get('rating_distribution', {})
        report += "### Risk Rating Breakdown\n"
        for rating in ['critical', 'high', 'medium', 'low']:
            count = rating_dist.get(rating, 0)
            percentage = (count / analysis_results['total_vulnerabilities'] * 100) if analysis_results['total_vulnerabilities'] > 0 else 0
            rating_emoji = {'critical': '🚨', 'high': '🔴', 'medium': '🟡', 'low': '🟢'}.get(rating, '❓')
            report += f"- **{rating.title()}**: {rating_emoji} {count} vulnerabilities ({percentage:.1f}%)\n"
        
        # Vulnerability type analysis
        type_analysis = portfolio_analysis.get('vulnerability_type_analysis', {})
        if type_analysis:
            report += f"""

### Vulnerability Type Risk Analysis
"""
            for vuln_type, data in sorted(type_analysis.items(), key=lambda x: x[1]['avg_score'], reverse=True):
                type_name = vuln_type.replace('_', ' ').title()
                avg_score = data['avg_score']
                count = data['count']
                risk_level = 'High' if avg_score >= 7 else 'Medium' if avg_score >= 4 else 'Low'
                report += f"- **{type_name}**: {avg_score:.1f}/10.0 average ({count} instances) - {risk_level} Risk\n"
        
        # Strategic recommendations
        recommendations = analysis_results.get('strategic_recommendations', [])
        report += f"""

### Strategic Recommendations
"""
        for i, rec in enumerate(recommendations, 1):
            priority = rec.split(':')[0]
            action = ':'.join(rec.split(':')[1:]).strip()
            report += f"{i}. **{priority}**: {action}\n"
        
        # Most critical findings
        most_exploitable = portfolio_analysis.get('most_exploitable_vulnerability', 'Unknown')
        report += f"""

### Critical Findings
- **Most Exploitable Vulnerability**: {most_exploitable}
- **Immediate Action Items**: {portfolio_analysis.get('immediate_action_required', 0)} vulnerabilities
- **Portfolio Risk Score**: {portfolio_analysis.get('portfolio_risk_score', 0):.2f}/10.0

### Exploitation Timeline Assessment
- **Critical vulnerabilities** can be exploited within **hours to days**
- **High-risk vulnerabilities** may be exploited within **days to weeks**
- **Detection window** for most attacks: **1-14 days** post-exploitation

### Regulatory and Compliance Impact
- **AI Safety Standards**: {'Non-Compliant' if portfolio_risk in ['critical', 'high'] else 'Compliant'}
- **Security Framework Alignment**: {'Requires Immediate Review' if executive_summary.get('executive_action_required', False) else 'Adequate'}
- **Incident Response Readiness**: {'Critical Gaps Identified' if portfolio_analysis.get('critical_vulnerabilities', 0) > 2 else 'Standard Monitoring Required'}

---

**Professional LLM Security Services**
For comprehensive exploitability assessment and vulnerability management:
- **VerityAI LLM Security Services**: [https://verityai.co](https://verityai.co)
- **Expert Consultation**: [Sotiris Spyrou](https://www.linkedin.com/in/sspyrou/)

*Portfolio demonstration - Contact for production exploitability assessment*
"""
        
        return report

def main():
    """Portfolio demonstration of exploitability analysis."""
    print("LLM Security Exploitability Analysis - Portfolio Demo")
    print("=" * 60)
    
    # Initialize analyzer
    analyzer = ExploitabilityAnalyzer()
    
    # Create sample vulnerabilities for demonstration
    sample_vulnerabilities = [
        VulnerabilityAssessment(
            vulnerability_id="VULN-001",
            vulnerability_type=VulnerabilityType.PROMPT_INJECTION,
            description="Direct instruction override vulnerability in customer service bot",
            exploitability_vector=ExploitabilityVector(
                access_vector=AccessVector.NETWORK,
                attack_complexity=ExploitComplexity.LOW,
                privileges_required=PrivilegeLevel.NONE,
                user_interaction=False,
                skill_level_required="Basic scripting",
                time_to_exploit="Hours",
                detection_likelihood="Low"
            ),
            technical_details={
                'proof_of_concept_available': True,
                'automated_exploitation_possible': True,
                'widespread_applicability': True
            },
            proof_of_concept="System override via crafted prompt injection",
            business_context={
                'customer_facing': True,
                'handles_sensitive_data': True,
                'regulatory_environment': 'financial'
            }
        ),
        
        VulnerabilityAssessment(
            vulnerability_id="VULN-002", 
            vulnerability_type=VulnerabilityType.SYSTEM_PROMPT_EXTRACTION,
            description="System prompt extraction through context manipulation",
            exploitability_vector=ExploitabilityVector(
                access_vector=AccessVector.NETWORK,
                attack_complexity=ExploitComplexity.MEDIUM,
                privileges_required=PrivilegeLevel.NONE,
                user_interaction=False,
                skill_level_required="Intermediate AI knowledge",
                time_to_exploit="Days",
                detection_likelihood="Medium"
            ),
            technical_details={
                'proof_of_concept_available': False,
                'automated_exploitation_possible': False,
                'requires_specific_model_version': True
            },
            proof_of_concept=None,
            business_context={
                'customer_facing': False,
                'handles_sensitive_data': False,
                'public_reputation_impact': True
            }
        ),
        
        VulnerabilityAssessment(
            vulnerability_id="VULN-003",
            vulnerability_type=VulnerabilityType.INFORMATION_LEAKAGE,
            description="PII exposure through inference attacks",
            exploitability_vector=ExploitabilityVector(
                access_vector=AccessVector.NETWORK,
                attack_complexity=ExploitComplexity.HIGH,
                privileges_required=PrivilegeLevel.LOW,
                user_interaction=True,
                skill_level_required="Advanced data analysis",
                time_to_exploit="Weeks",
                detection_likelihood="High"
            ),
            technical_details={
                'requires_multiple_sessions': True,
                'statistical_analysis_required': True
            },
            proof_of_concept="Statistical inference attack on training data",
            business_context={
                'handles_sensitive_data': True,
                'regulatory_environment': 'healthcare',
                'customer_facing': True
            }
        )
    ]
    
    # Analyze portfolio exploitability
    analysis_results = analyzer.analyze_portfolio_exploitability(sample_vulnerabilities)
    
    # Generate report
    exploitability_report = analyzer.generate_exploitability_report(analysis_results)
    
    print("EXPLOITABILITY ANALYSIS COMPLETED")
    print(f"Vulnerabilities Analyzed: {analysis_results['total_vulnerabilities']}")
    
    portfolio_analysis = analysis_results['portfolio_analysis']
    print(f"Portfolio Risk Level: {portfolio_analysis['portfolio_risk_level'].upper()}")
    print(f"Critical Vulnerabilities: {portfolio_analysis['critical_vulnerabilities']}")
    print(f"Average Exploitability: {portfolio_analysis['score_statistics']['mean']:.2f}/10.0")
    print(f"Immediate Actions Required: {portfolio_analysis['immediate_action_required']}")
    
    print("\nExecutive Exploitability Report:")
    print(exploitability_report)
    
    print("\n" + "=" * 60)
    print("Portfolio Demo by Sotiris Spyrou")
    print("LinkedIn: https://www.linkedin.com/in/sspyrou/")
    print("Professional LLM Security Services: https://verityai.co")

if __name__ == "__main__":
    logging.basicConfig(level=logging.INFO)
    main()